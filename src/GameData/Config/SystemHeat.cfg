// SystemHeat integration.
//
// Most of the modules for SystemHeat are pretty straightforward. We don't
// really care about the extra features they have and they behave exactly
// like the stock module they replace in terms of resource processing.

BACKGROUND_CONVERTER:NEEDS[SystemHeat]
{
    name = ModuleSystemHeatConverter
    adapter = BackgroundResourceConverter

    UsePreparedRecipe = false
}

BACKGROUND_CONVERTER:NEEDS[SystemHeat]
{
    name = ModuleSystemHeatHarvester
    adapter = BackgroundResourceHarvester

    UsePreparedRecipe = false
}

BACKGROUND_CONVERTER:NEEDS[SystemHeat]
{
    name = ModuleSystemHeatAsteroidHarvester
    adapter = BackgroundAsteroidDrill

    UsePreparedRecipe = false
    MassResourceName = BRPSpaceObjectMass
}

BACKGROUND_CONVERTER:NEEDS[SystemHeat]
{
    name = ModuleSystemHeatCometHarvester
    adapter = BackgroundCometDrill

    UsePreparedRecipe = false
}

BACKGROUND_CONVERTER:NEEDS[SystemHeat]
{
    name = ModuleSystemHeatFissionReactor
    adapter = SelectFirst

    ActiveCondition = %Enabled

    // For manual control we pre-apply the throttle to all resource rates and
    // then set DumpExcess = True on the EC output so that the reactor always
    // runs at the designated throttle (unless it runs out of resources).
    BACKGROUND_CONVERTER
    {
        condition = %ManualControl
        adapter = BackgroundConstantConverter
        
        InputList = %inputs
        OutputList = %outputs

        LastUpdateField = LastUpdateTime

        OUTPUT_RESOURCE
        {
            condition = %GeneratesElectricity

            ResourceName = ElectricCharge
            // We multiply everything by %CurrentThrottle * 0.01 but we don't
            // want to apply that to electrical generation so we divide in advance.
            Ratio = %ElectricalGeneration.Evaluate(%CurrentThrottle) / (%CurrentThrottle * 0.01)
            DumpExcess = True
            FlowMode = ALL_VESSEL
        }

        MULTIPLIER
        {
            Value = %CurrentThrottle * 0.01
        }
    }

    // If the reactor generates electricity then electricity usage will naturally
    // throttle it to the correct level.
    BACKGROUND_CONVERTER
    {
        adapter = BackgroundConstantConverter
        condition = %GeneratesElectricity

        InputList = %inputs
        OutputList = %outputs

        LastUpdateField = LastUpdateTime

        OUTPUT_RESOURCE
        {
            ResourceName = ElectricCharge
            Ratio = %ElectricalGeneration.Evaluate(100)
            DumpExcess = False
            FlowMode = ALL_VESSEL
        }
    }

    // Otherwise, the reactor does not produce electricity. If it can hibernate
    // then we do so.
    BACKGROUND_CONVERTER
    {
        condition = %Hibernating || %HibernateOnWarp
        adapter = BackgroundConstantConverter
        ActiveCondition = false
    }

    // If the reactor is not permitted to hibernate, then we leave it idling at
    // its minimum throttle.
    BACKGROUND_CONVERTER
    {
        condition = %MinimumThrottle > 0
        adapter = BackgroundConstantConverter

        InputList = %inputs
        OutputList = %outputs

        LastUpdateField = LastUpdateTime

        MULTIPLIER
        {
            Value = %MinimumThrottle
        }
    }
}

// For our purposes we can treat a fission engine just like a fission reactor.
+BACKGROUND_CONVERTER[ModuleSystemHeatFissionReactor]:FIRST:NEEDS[SystemHeat]
{
    @name = ModuleSystemHeatFissionEngine
}

BACKGROUND_CONVERTER:NEEDS[SystemHeat]
{
    name = ModuleSystemHeatRadiator
    adapter = BackgroundGenericConverter

    ActiveCondition = %IsCooling
}
